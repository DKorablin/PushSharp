name: Test, Build, Release

on:
  workflow_dispatch:

env:
  SolutionName: ${{github.event.repository.name}}
  DotNetVersion: 8.0.x

jobs:
  version:
    name: Tag / Version
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.tag_version.outputs.new_version }}
      new_tag: ${{ steps.tag_version.outputs.new_tag }}
      changelog: ${{ steps.tag_version.outputs.changelog }}
    steps:
    - name: Tag version
      id: tag_version
      uses: mathieudutour/github-tag-action@v6.2
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        #custom_tag: 4.1.0

  build_net:
    name: Build
    needs: [version]
    runs-on: windows-latest
    steps:
    - name: Decode strong-name key
      id: sign_key_file
      uses: timheuer/base64-to-file@v1.2
      with:
        fileName: 'Signature.snk'
        encodedString: ${{ secrets.SIGN_ASM_KEY }}
    - uses: actions/checkout@v4
      with:
        submodules: true
    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
        restore-keys: |
          ${{ runner.os }}-nuget-
    - name: Restore
      run: msbuild ${{ env.SolutionName }}.sln /t:Restore
    - name: Build multi-target project
      shell: pwsh
      run: |
        $csprojFiles = Get-ChildItem -Path ${{github.workspace}} -Recurse -Filter *.csproj
        Where-Object {
          $_.Name -notmatch '(35|Tests)\.csproj$'
        }

        foreach ($proj in $csprojFiles) {
            Write-Host "Building $($proj.FullName)..."
            msbuild "$($proj.FullName)" `
                /p:Configuration=Release `
                /p:BaseOutputPath="${{ github.workspace }}\bin\" `
                /p:GenerateDocumentationFile=true `
                /p:SignAssembly=true `
                /p:Version=${{ needs.version.outputs.new_version }} `
                /p:AssemblyOriginatorKeyFile="${{ steps.sign_key_file.outputs.filePath }}"

            if ($LASTEXITCODE -ne 0) {
                Write-Error "Build failed for $($proj.FullName)"
            } else {
                Write-Host "Build succeeded for $($proj.FullName)"
            }
        }
    #TODO: I need to find a better approach to sign output files without explicitly specify filename and extension
    - name: Signing PushSharp Assemblies
      uses: dlemstra/code-sign-action@v1
      with:
        certificate: '${{ secrets.SIGN_PE_CERTIFICATE }}'
        password: '${{ secrets.SIGN_PE_PASSWORD }}'
        recursive: false
        files: |
          ${{github.workspace}}\bin\PushSharp.Core.dll
          ${{github.workspace}}\bin\PushSharp.Amazon.dll
          ${{github.workspace}}\bin\PushSharp.Apple.dll
          ${{github.workspace}}\bin\PushSharp.Blackberry.dll
          ${{github.workspace}}\bin\PushSharp.Google.dll
          ${{github.workspace}}\bin\PushSharp.Huawei.dll
          ${{github.workspace}}\bin\PushSharp.Windows.dll
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.SolutionName }}_Binaries
        path: ${{github.workspace}}\bin\Release\*
        if-no-files-found: error
        compression-level: 0
        retention-days: 1

  deploy_release:
    name: Deploying release
    needs: [version, build_net]
    if: needs.build_net.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write
    steps:
    - name: Download artifacts
      uses: actions/download-artifact@v4
      with:
        path: bin
    - name: Zipping artifacts
      run: |
        cd ${{github.workspace}}/bin/${{ env.SolutionName }}_Binaries
        for dir in */; do
          dir_name="${dir%/}"
          (cd "$dir_name" && zip -qq -r "../${{env.SolutionName}}_v${{needs.version.outputs.new_version}}_${dir_name}.zip" .)
        done
    - name: Publish GitHub Release
      uses: ncipollo/release-action@v1
      with:
        artifacts: ${{github.workspace}}/bin/${{ env.SolutionName }}_Binaries/*.zip
        tag: ${{ needs.version.outputs.new_tag }}
        name: Auto ${{ needs.version.outputs.new_tag }}
        body: ${{ needs.version.outputs.changelog }}
        artifactErrorsFailBuild: true
        generateReleaseNotes: true

  deploy_nuget:
    name: Deploying NuGet package
    needs:
        - version
        - build_net
    runs-on: windows-latest
    steps:
    - name: Checkout nessesary files from repository
      uses: actions/checkout@v4
      with:
        sparse-checkout: |
          README.md
          Resources/PushSharp-Icon-NuGet-Small.png
          ${{env.SolutionName}}.nuspec
        sparse-checkout-cone-mode: false
    - name: Download artifacts
      uses: actions/download-artifact@v4
      with:
        path: bin
    - name: Packing artifacts
      run: nuget pack ${{env.SolutionName}}.nuspec -Version ${{needs.version.outputs.new_version}} -OutputDirectory nupkg
    - name: Deploying to GitHub
      run: dotnet nuget push nupkg\*.nupkg --skip-duplicate --api-key ${{secrets.GITHUB_TOKEN}} --source https://nuget.pkg.github.com/DKorablin/index.json
#    - name: Deploying to NuGet
#      run: dotnet nuget push nupkg\*.nupkg --skip-duplicate --api-key ${{secrets.NUGET_TOKEN}} --source https://api.nuget.org/v3/index.json

  failure_cleanup:
    name: Cleanup Tag On Failure
    needs: [version, build_net]
    if: always() && needs.build_net.result != 'success'
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
      with:
        submodules: false
        fetch-depth: 0
    - name: Remove created tag
      run: |
        git tag -d ${{ needs.version.outputs.new_tag }} || true
        git push origin :refs/tags/${{ needs.version.outputs.new_tag }} || true